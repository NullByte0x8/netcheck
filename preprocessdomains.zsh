#!/bin/zsh
#
# This script will read a list of domains (presumably one generated by get-top-1000-hungary-web-domains or a similar script) and massages it, using adnshost, into a hash of IP address to domain mappings, using the filesystem as the database.
#
# This directory structure can then be used to facilitate connectivity tests: you can get 100 random IPs that are expected to run highly available webservers and see how many of them you can reach.
#
# This script should be re-run relatively frequently (at least hourly); the DNS data it collects is expected to be volatile, and we cache them indefinitely, with no regard to the TTL. Whatever uses the output should expect to see a few stale IPs.
#
# We currently only deal with IPv4 addresses.

CONFIG=/etc/default/${0:t}
INFILE=${INFILE:-/var/lib/netcheck/domains}
RUNASUSER=nobody
OUTDIR=/run/netcheck/ips # a symlink called "latest" will be created when we're done, pointing to the current data
MINDOMAINS=1000	# Bail unless the input has at least this many lines
MINIPS=200 # Bail unless the number of IPs we resolve is at least this amount

script_exit_code=0
function hook_top() {	# this function will be called before we do anything else and must return successfully for the script to do anything. You can override it in the config (and use it to implement arbitrary checks to perform before other operations).
	return 0	# if the return code is nonzero, the script aborts with $script_exit_code before doing anything else
}

function hook_bottom() {	# this function will be called (as root) if there were no fatal errors and all sanity checks succeeded, just before exiting. Its return value sets the exit code of the script. You can override it in the configuration.
	return 0
}

[[ -r $CONFIG ]] && . $CONFIG

hook_top || exit $script_exit_code

typeset -A ip_to_domain

numdomains=$(wc -l <$INFILE)
if [[ $numdomains -lt $MINDOMAINS ]]; then
	echo "$0: FATAL: $INFILE only contains $numdomains lines, less than MINDOMAINS (set to $MINDOMAINS)." >&2
	exit 1
fi

install -d -o $RUNASUSER $OUTDIR

[[ -v TMPDIR ]] && { [[ -w $TMPDIR ]] || unset TMPDIR }
tmpdir=$(USERNAME=$RUNASUSER mktemp -d -p $OUTDIR) || exit 111

# unprivileged bits
(
	USERNAME=$RUNASUSER 

	# Construct an ip to domain hash in memory
	adnshost -a -A4 -Cl -f <$INFILE \
	| grep -w 'A INET' \
	| while read domain A INET ip; do
		if [[ -v ip_to_domain[$ip] ]]; then
			ip_to_domain[$ip]="$ip_to_domain[$ip], $domain"
		else
			ip_to_domain[$ip]="$domain"
		fi
	done
	if [[ ${(k)#ip_to_domain} -lt $MINIIPS ]]; then
		echo "$0: FATAL: the $numdomains domains only resolved to ${(k)#ip_to_domain} distinct IPs, less than MINIPS (set to $MINIPS)." >&2
		exit 1
	fi

	# Generate output (as RUNASUSER)
	for i in ${(k)ip_to_domain}; do
		echo $ip_to_domain[$i] >$tmpdir/$i
	done
	chmod 755 $tmpdir

	if [[ -L $OUTDIR/latest ]]; then
		olddir=$(readlink $OUTDIR/latest)
	else
		unset olddir
	fi
	ln -sfT ${tmpdir:t} $OUTDIR/latest || exit 111
	[[ -v olddir ]] && rm -rf $OUTDIR/$olddir	# we only ever create relative symlinks to directories within OUTDIR, so this is the only safe kind to remove, even as nobody
) || exit $?
hook_bottom
exit $?
